"""
在算法设计中，我们先后追求以下两个层面的目标。

找到问题解法：算法需要在规定的输入范围内可靠地求得问题的正确解。
寻求最优解法：同一个问题可能存在多种解法，我们希望找到尽可能高效的算法。
也就是说，在能够解决问题的前提下，算法效率已成为衡量算法优劣的主要评价指标，它包括以下两个维度。

时间效率：算法运行时间的长短。
空间效率：算法占用内存空间的大小。
简而言之，我们的目标是设计“既快又省”的数据结构与算法。而有效地评估算法效率至关重要，因为只有这样，我们才能将各种算法进行对比，进而指导算法设计与优化过程。

复杂度分析能够体现算法运行所需的时间和空间资源与输入数据大小之间的关系。它描述了随着输入数据大小的增加，算法执行所需时间和空间的增长趋势。这个定义有些拗口，我们可以将其分为三个重点来理解。

“时间和空间资源”分别对应时间复杂度（time complexity）和空间复杂度（space complexity）。
“随着输入数据大小的增加”意味着复杂度反映了算法运行效率与输入数据体量之间的关系。
“时间和空间的增长趋势”表示复杂度分析关注的不是运行时间或占用空间的具体值，而是时间或空间增长的“快慢”。


时间复杂度
去掉常数项、低次项和系数，保留最高次项，即为时间复杂度。
时间复杂度描述的是算法运行时间与输入数据之间的增长关系，而不是算法的运行时间。

分析在输入规模为 n 时，基本操作执行的次数。可以通过以下几种方式来分析：
循环：计算循环的次数。例如，一个从 1 到 n 的循环，基本操作执行 n 次
嵌套循环：如果有嵌套循环，外层循环执行 n 次，内层循环也执行 n 次，那么基本操作的总次数是 n×n=n^2。
递归：使用递归时，可以建立递推关系来计算。例如，斐波那契数列的递归实现会有 2^n 的时间复杂度。

空间复杂度
空间复杂度描述的是算法占用的内存空间与输入数据之间的增长关系，而不是算法占用的内存空间。



"""

# lst = [9, 3, 6, 8, 10, 2, 1, 15, 7, 8]
# lst.sort()
# print(lst)

# # 冒泡排序
# lst = [9, 3, 6, 8, 10, 2, 1, 15, 7, 8]
# num = len(lst)
#
#
# def bubble_sort():
#     for i in range(num - 1):
#         for j in range(num - i - 1):
#             if lst[j] > lst[j + 1]:
#                 lst[j], lst[j + 1] = lst[j + 1], lst[j]
#
#
# bubble_sort()
# print(lst)

# # 选择排序
# lst = [9, 3, 6, 8, 10, 2, 1, 15, 7, 8]
# num = len(lst)
#
#
# def select_sort():
#     for i in range(num - 1):
#         for j in range(i + 1, num):
#             if lst[i] > lst[j]:
#                 lst[i], lst[j] = lst[j], lst[i]
#
#
# select_sort()
# print(lst)

# 插入排序
lst = [9, 3, 6, 8, 10, 2, 1, 15, 7, 8]
num = len(lst)


def insert_sort():
    for i in range(1, num):
        pass
