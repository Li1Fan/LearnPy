"""
迭代（iteration）是一种重复执行某个任务的控制结构。
在迭代中，程序会在满足一定的条件下重复执行某段代码，直到这个条件不再满足。

递归（recursion）是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。

递：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。
归：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。

尾递归（tail recursion）
是指递归函数中所有递归调用都出现在函数末尾的情况。尾递归函数的特点是在递归调用后直接返回结果，不再有其他操作。

迭代	递归
实现方式	循环结构	函数调用自身
时间效率	效率通常较高，无函数调用开销	每次函数调用都会产生开销
内存使用	通常使用固定大小的内存空间	累积函数调用可能使用大量的栈帧空间
适用问题	适用于简单循环任务，代码直观、可读性好	适用于子问题分解，如树、图、分治、回溯等，代码结构简洁、清晰
"""
total = 0
for i in range(1, 11):
    total += i
print(total)


def recur(n: int) -> int:
    """递归"""
    # 终止条件
    if n == 1:
        return 1
    # 递：递归调用
    res = recur(n - 1)
    # 归：返回结果
    return n + res


print(recur(10))


def fib(n: int) -> int:
    """斐波那契数列：递归"""
    # 终止条件 f(1) = 0, f(2) = 1
    if n == 1 or n == 2:
        return n - 1
    # 递归调用 f(n) = f(n-1) + f(n-2)
    res = fib(n - 1) + fib(n - 2)
    # 返回结果 f(n)
    return res


for i in range(1, 99):
    print(fib(i), end=' ')
